# Vulnerability Patterns — PayLobster

## Smart Contract Patterns

### Reentrancy
- Check all external calls in escrow release/claim functions
- Ensure state updates happen BEFORE external calls (checks-effects-interactions)
- Look for `.call{value:}` or `.transfer()` followed by state changes
- Verify USDC `transfer()` uses SafeERC20 or checks return values

### Access Control
- Every admin function must have `onlyOwner` or role-based modifier
- Verify `registerAgent()` can't be called to impersonate existing agents
- Check escrow `release()` / `dispute()` — only buyer/seller should call
- Verify credit score update functions are restricted to authorized oracle

### Integer Issues
- USDC uses 6 decimals — check all amount calculations for precision loss
- Verify no overflow in credit limit calculation (score × multiplier)
- Check milestone percentages sum to 100%

### Front-Running
- Escrow creation + funding should be atomic or use commit-reveal
- Check if escrow release can be front-run by MEV bots
- Verify dispute resolution voting can't be gamed

### Token Approval Risks
- Never approve unlimited USDC (`type(uint256).max`) from user wallets
- Verify approval amounts match exact transaction needs
- Check for approval race conditions

## Web Application Patterns

### Authentication Bypass
- Verify every `/api/*` route checks session/JWT
- Check for inconsistency between NextAuth and Firebase auth states
- Test SIWE (Sign-In with Ethereum) message replay attacks
- Verify session expiry and refresh token rotation

### Injection
- All user inputs rendered in JSX must be escaped (React default)
- Check `dangerouslySetInnerHTML` usage — grep for it
- SQL/NoSQL injection in Firestore queries — verify input sanitization
- Command injection in any `exec()` or `spawn()` calls

### API Security
- Rate limit all payment-related endpoints
- Verify webhook URLs are validated (no SSRF via internal URLs)
- Check API key generation entropy in merchant API
- Verify charge/payment IDs are not sequential (use UUIDs)

### Data Exposure
- Never return private keys, secrets, or full wallet addresses in API responses
- Check that error messages don't leak stack traces in production
- Verify server components don't pass sensitive data to client components
- Check `next.config.js` for exposed environment variables

## x402 Protocol Patterns

### Payment Proof Replay
- Verify payment proofs include nonce or timestamp
- Check that server validates proof hasn't been used before
- Ensure proof is bound to specific request (not transferable)

### Amount Manipulation
- Server must enforce pricing — never trust client-specified amounts
- Verify 402 response includes cryptographic commitment to price
- Check for TOCTOU between price quote and payment verification

## SDK / CLI Patterns

### Trust-Gate Bypass
- Verify trust score is fetched from chain, not from cache/local
- Check that `allowUnscored` flag can't be set by untrusted input
- Verify exception list (whitelist) is stored securely

### Spending Limit Circumvention
- Check for race conditions in concurrent transactions
- Verify daily/weekly/monthly resets use UTC consistently
- Ensure spending records can't be deleted or tampered with

### Secret Handling
- API keys must come from env vars, never hardcoded
- Circle entity secret must be encrypted at rest
- Audit log must not contain sensitive data (amounts OK, keys NOT OK)

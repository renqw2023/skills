id,name,category,description,use_case,tradeoffs,complexity,scale
1,Monolith,Application Architecture,Single deployable unit containing all application logic and components,Small teams building MVPs or simple applications with limited scope,Simple deployment and debugging but poor scalability and tight coupling,low,small
2,Modular Monolith,Application Architecture,Monolith organized into well-defined modules with clear boundaries and interfaces,Teams wanting modularity without distributed system complexity; migration stepping stone,Better organization than monolith but still single deployment unit; good balance of simplicity and structure,medium,medium
3,Microservices,Application Architecture,Application decomposed into small independent services each owning its domain and data,Large teams needing independent deployment scaling and technology diversity,Independent scaling and deployment but operational complexity and distributed system challenges,high,enterprise
4,Serverless,Application Architecture,Application built on cloud functions that execute on demand without managing infrastructure,Event-driven workloads with variable traffic; rapid prototyping; cost-sensitive projects,Zero infrastructure management and pay-per-use but vendor lock-in cold starts and debugging difficulty,medium,large
5,Service-Oriented Architecture (SOA),Application Architecture,Coarse-grained services communicating via enterprise service bus with shared data contracts,Enterprise integration across legacy systems; large organizations with diverse technology stacks,Reusability and enterprise integration but heavyweight middleware and complex governance,high,enterprise
6,Event-Driven Architecture,Application Architecture,Components communicate through asynchronous events enabling loose coupling and reactivity,Real-time processing systems; systems requiring high decoupling; IoT and streaming platforms,Excellent decoupling and scalability but eventual consistency complexity and harder debugging,high,large
7,CQRS,Application Architecture,Separates read and write models allowing independent optimization of query and command paths,Systems with asymmetric read/write loads; complex domains requiring different read/write representations,Optimized read/write performance but increased complexity and eventual consistency between models,high,large
8,Event Sourcing,Application Architecture,Stores all state changes as immutable events rebuilding current state by replaying the event log,Audit-critical systems; systems needing complete history; financial and compliance applications,Complete audit trail and temporal queries but storage growth complexity and eventual consistency,high,large
9,Clean Architecture,Structural Patterns,Concentric layers with dependencies pointing inward; domain at center independent of frameworks,Applications requiring long-term maintainability testability and framework independence,High testability and flexibility but more boilerplate and initial setup overhead,medium,medium
10,Hexagonal (Ports & Adapters),Structural Patterns,Core domain surrounded by ports defining interfaces and adapters implementing external integrations,Applications needing swappable infrastructure; systems with multiple integration points,Easy to test and swap integrations but requires discipline to maintain port/adapter boundaries,medium,medium
11,Onion Architecture,Structural Patterns,Similar to clean architecture with domain model at core and infrastructure at outermost layer,Domain-heavy applications where business logic must remain isolated from infrastructure concerns,Strong domain isolation and testability but learning curve and potential over-engineering for simple apps,medium,medium
12,Layered Architecture,Structural Patterns,Horizontal layers where each layer only communicates with the layer directly below it,Traditional enterprise applications; teams familiar with n-tier patterns; CRUD-heavy applications,Simple to understand and implement but can lead to tight coupling between layers and god classes,low,small
13,Domain-Driven Design,Structural Patterns,Software design approach aligning code structure with business domains using ubiquitous language,Complex business domains with rich logic; large teams needing shared understanding of the domain,Deep business alignment and maintainability but steep learning curve and overhead for simple domains,high,enterprise
14,Plugin Architecture,Structural Patterns,Core system with extension points allowing third-party plugins to add functionality dynamically,Extensible platforms like IDEs editors and CMS; products requiring customization without core changes,High extensibility and customization but plugin compatibility management and security concerns,medium,large
15,Pipe and Filter,Structural Patterns,Data flows through a series of processing components each transforming input to output,Data processing pipelines; ETL systems; compiler design; stream processing applications,Easy to add remove and reorder processing steps but overhead from data transformation between stages,low,medium
16,Blackboard Pattern,Structural Patterns,Shared knowledge base where specialized subsystems collaboratively build a solution,AI and expert systems; complex problem solving requiring multiple specialized algorithms,Enables collaborative problem solving but complex coordination and potential performance bottlenecks,high,large
17,Request-Response,Communication Patterns,Synchronous communication where client sends request and waits for server response,Simple API interactions; CRUD operations; when immediate response is required,Simple and intuitive but tight coupling between client and server; blocking calls reduce throughput,low,small
18,Publish-Subscribe,Communication Patterns,Publishers emit events to topics and subscribers receive events they are interested in,Broadcasting events to multiple consumers; decoupled notification systems; real-time updates,Excellent decoupling and scalability but message ordering challenges and debugging complexity,medium,large
19,Message Queue,Communication Patterns,Asynchronous communication via queues ensuring reliable message delivery between services,Workload buffering; reliable async processing; handling traffic spikes; background job processing,Reliable delivery and load leveling but added infrastructure complexity and potential message duplication,medium,large
20,API Gateway,Communication Patterns,Single entry point that routes requests to appropriate backend services handling cross-cutting concerns,Microservices architectures needing unified API; mobile backends; rate limiting and auth aggregation,Simplified client interface and centralized concerns but single point of failure and added latency,medium,large
21,Service Mesh,Communication Patterns,Infrastructure layer handling service-to-service communication with observability security and reliability,Large microservices deployments needing consistent networking policies; zero-trust security models,Transparent networking and observability but significant operational complexity and resource overhead,high,enterprise
22,Saga Pattern,Communication Patterns,Manages distributed transactions across services using a sequence of local transactions with compensations,Distributed transactions spanning multiple services; long-running business processes requiring consistency,Maintains consistency without distributed locks but complex compensation logic and partial failure handling,high,large
23,Choreography,Communication Patterns,Services coordinate through events without central controller each reacting to events from others,Simple workflows with few services; when decentralization and autonomy are priorities,No single point of failure and loose coupling but harder to track workflows and potential cyclic dependencies,medium,large
24,Orchestration,Communication Patterns,Central orchestrator coordinates workflow by directing service calls and managing the overall process,Complex workflows requiring visibility; processes needing central error handling and monitoring,Clear workflow visibility and easier debugging but central point of failure and potential bottleneck,medium,large
25,Database per Service,Data Patterns,Each microservice owns and manages its private database with no direct database sharing,Microservices requiring data independence; teams needing autonomous schema evolution,Full data autonomy and independent scaling but cross-service queries are complex and data consistency challenges,high,large
26,Shared Database,Data Patterns,Multiple services access the same database schema sharing tables and data directly,Small teams or monoliths transitioning to services; when strong consistency is critical across services,Simple data access and strong consistency but tight coupling schema change coordination and scaling limits,low,small
27,CQRS with Event Sourcing,Data Patterns,Combines separated read/write models with event log as source of truth for all state changes,High-performance systems needing audit trails; complex domains with asymmetric read/write patterns,Ultimate flexibility and audit capability but highest complexity requiring deep expertise to implement well,high,enterprise
28,Data Lake,Data Patterns,Centralized repository storing raw data at any scale in native format for analytics and processing,Big data analytics; machine learning pipelines; organizations consolidating diverse data sources,Stores any data format at scale but can become a data swamp without governance; query performance varies,medium,enterprise
29,Data Mesh,Data Patterns,Decentralized data architecture treating data as a product owned by domain teams with self-serve platform,Large organizations with many data domains; when centralized data teams become bottlenecks,Domain ownership and scalability but requires organizational change and mature data platform,high,enterprise
30,Polyglot Persistence,Data Patterns,Using different database technologies for different services based on their specific data access patterns,Systems with diverse data needs; when no single database type fits all service requirements,Optimal storage per use case but operational complexity of managing multiple database technologies,medium,large
31,Read Replicas,Data Patterns,Primary database handles writes while read-only copies serve read queries distributing read load,Read-heavy applications; reporting systems; geographic distribution of read traffic,Improved read performance and availability but replication lag and eventual consistency for reads,medium,large
32,Sharding,Data Patterns,Horizontally partitioning data across multiple database instances based on a shard key,Very large datasets exceeding single database capacity; high-throughput write-heavy applications,Near-linear horizontal scaling but cross-shard queries are complex and rebalancing is operationally heavy,high,enterprise
33,Blue-Green Deployment,Deployment Patterns,Two identical production environments where traffic switches from current (blue) to new (green) version,Zero-downtime deployments; environments requiring instant rollback capability,Instant rollback and zero downtime but double infrastructure cost and database migration complexity,medium,large
34,Canary Release,Deployment Patterns,Gradually rolling out changes to a small subset of users before full deployment to catch issues early,Risk-sensitive deployments; validating changes with real traffic before wide release,Early issue detection with limited blast radius but requires traffic splitting infrastructure and monitoring,medium,large
35,Rolling Update,Deployment Patterns,Gradually replacing instances of the old version with new version one at a time across the fleet,Standard deployments for stateless services; Kubernetes default deployment strategy,No extra infrastructure needed and gradual rollout but mixed versions during update and slower rollback,low,medium
36,Feature Flags,Deployment Patterns,Toggles controlling feature visibility at runtime allowing deployment independent of feature release,Trunk-based development; A/B testing; gradual feature rollouts; kill switches for new features,Decouple deployment from release and enable testing in production but flag debt and increased code complexity,medium,large
37,Strangler Fig,Deployment Patterns,Incrementally replacing legacy system by routing requests to new implementation piece by piece,Legacy system modernization; gradual migration from monolith to microservices,Low-risk incremental migration but requires routing layer and extended period of running two systems,medium,large
38,Branch by Abstraction,Deployment Patterns,Introducing abstraction layer to allow old and new implementations to coexist during migration,Replacing components within a monolith; swapping infrastructure dependencies without big-bang migration,Safe incremental replacement but abstraction layer overhead and temporary code complexity,medium,medium
39,Shadow Deploy,Deployment Patterns,New version receives copy of production traffic for comparison but responses are discarded,Validating performance and correctness of new version with real traffic without user impact,Real traffic validation without risk but double resource usage and no validation of write-path side effects,high,enterprise
40,A/B Testing,Deployment Patterns,Running two variants simultaneously with different user segments to measure which performs better,Product feature validation; UI/UX optimization; conversion rate optimization; data-driven decisions,Data-driven decisions and measurable impact but requires statistical rigor and user segmentation infrastructure,medium,large
41,Circuit Breaker,Resilience Patterns,Prevents cascading failures by stopping calls to failing services and providing fallback behavior,Protecting services from downstream failures; preventing cascade failures in distributed systems,Prevents cascade failures and enables graceful degradation but adds complexity and requires tuning thresholds,medium,large
42,Bulkhead,Resilience Patterns,Isolates components into pools so failure in one does not drain resources from others,Isolating critical from non-critical workloads; preventing resource exhaustion from affecting all consumers,Failure isolation and resource protection but reduced overall resource utilization and configuration complexity,medium,large
43,Retry with Backoff,Resilience Patterns,Automatically retries failed operations with increasing delays between attempts to handle transient failures,Handling transient network failures; unreliable external service calls; eventual consistency scenarios,Handles transient failures transparently but can amplify load on struggling services without proper limits,low,medium
44,Timeout,Resilience Patterns,Sets maximum duration for operations preventing indefinite waits for unresponsive services,All remote service calls; database queries; any operation that could hang indefinitely,Prevents resource exhaustion from hung calls but too-aggressive timeouts cause false failures on slow operations,low,medium
45,Fallback,Resilience Patterns,Provides alternative behavior or cached data when primary operation fails ensuring degraded but functional service,User-facing services needing graceful degradation; systems with acceptable fallback responses,Maintains availability during failures but fallback data may be stale and adds maintenance burden,low,medium
46,Cache-Aside,Resilience Patterns,Application checks cache before database loading cache on miss; improves performance and provides resilience,Read-heavy workloads; reducing database load; providing stale data during database outages,Improved performance and database resilience but cache invalidation complexity and potential stale data,medium,large
47,Health Check,Resilience Patterns,Services expose endpoints reporting their status enabling load balancers and orchestrators to manage traffic,Container orchestration; load balancer routing; service discovery; monitoring and alerting,Automated failure detection and traffic management but health check logic must accurately reflect service state,low,medium
48,Rate Limiting,Resilience Patterns,Controls the rate of incoming requests preventing abuse and ensuring fair resource usage across consumers,Public APIs; multi-tenant systems; protecting services from traffic spikes and denial of service,Protects service stability and ensures fairness but can reject legitimate traffic if limits are too aggressive,medium,large
